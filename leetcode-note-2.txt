按照 github 中 CyC2018/CS-Notes 项目中 Leetcode 题解目录
算法思想
  双指针
    1.有序数组的 Two Sum
      #167.两数之和 II - 输入有序数组  
        双指针，缩减搜索空间
        二分查找，遍历，在右侧空间二分查找
    2.两数平方和
      #633.平方数之和
        双指针，右指针初始化sqrt(target)实现剪枝
        二分查找，遍历第一个数，二分查找第二个数
        费马平方和定理
    3.反转字符串中的元音字符
      #345.反转字符串中的元音字母
        双指针
    4.回文字符串
      #680.验证回文字符串 II
        双指针，遇到不同时，删除左指针或右指针指向的字符
    5.归并两个有序数组
      #88.合并两个有序数组
        双指针，从后往前
    6.判断链表是否存在环
      #141.环形链表
        快慢指针，判断是否会相遇
        哈希表，存储访问过的结点
    7.最长子序列
      #524.通过删除字母匹配到字典里最长单词
        遍历字典，双指针判断一个字符串是否为另一个字符串的子序列
        递归暴力生成字符串的所有子串
        二进制位，迭代暴力生成字符串的所有子串
  排序
    快速选择
    堆
      1.Kth Element
        #215.数组中的第K个最大元素
          快速排序，每次 partition 返回 pivot 下标
          堆，k个元素的最小堆
          整个数组排序后，取下标
    桶排序
      1.出现频率最多的 k 个元素
        #347.前 K 个高频元素
          桶排序
          堆
      2.按照字符出现次数堆字符串排序
        #451.根据字符出现频率排序
          桶排序
    荷兰国旗问题
      1.按颜色进行排序
        #75.颜色分类
          三向切分快速排序，注意边界
  贪心思想
    1.分配饼干
      #455.分发饼干
        贪心，先将小孩胃口和饼干分别排序，然后双指针比较移动
    2.不重叠的区间个数
      #435.无重叠区间
        贪心，从起始点/从终点
        动态规划，从起始点/从终点
        暴力，递归枚举所有情况
    3.投飞镖刺破气球
      #452.用最少数量的箭引爆气球
        贪心，寻找无重叠区间个数
    4.根据身高和序号重组队列
      #406.根据身高重建队列
        贪心，身高降序，序号升序，依次插入list
    5.买卖股票最大的收益
      #121.买卖股票的最佳时机
        贪心，遍历记录最低价更新收益
    6.买卖股票的最大收益II
      #122.买卖股票的最佳时机II
        贪心，遍历只要比前一天价格高就增加收益
        动态规划
    7.种植花朵
      #605.种花问题
        贪心，遍历判断前后有没有花，注意第一个前面和最后一个后面没有花
    8.判断是否为子序列
      #392.判断子序列
        双指针
        后续挑战，动态规划，二维数组记录下一个要匹配的字符位置
    9.修改一个数为非递减数组
      #665.非递减数列
        遍历，比较，替换，注意2种替换情况
    10.子数组最大的和
      #53.最大子序和
        遍历，记录当前最大子序和，更新最大结果
    11.分隔字符串使同种字符出现在一起
      #763.划分字母区间
        贪心，记录每个字符的最大下标，遍历比较本子串最大下标于当前下标
  二分查找
    1.求开方
      #69.x的平方根
        二分法，注意0，1，2，3特殊情况
        牛顿法，迭代公式 x = 0.5 * (x + c / x);
    2.大于给定元素的最小元素
      #744.寻找比目标字母大的最小元素
        二分法，注意所有值都小于target的边界情况
    3.有序数组的 Single Element
      #540.有序数组中的单一元素
        二分法，只需对偶数索引进行二分搜索
    4.第一个错误的版本
      #278.第一个错误的版本
        二分法，求满足条件的最左边的值
    5.旋转数字的最小数字
      #153.寻找旋转排序数组中的最小值
        二分法，注意数组长度为1的情况
    6.查找区间
      #34.在排序数组中查找元素的第一个和最后一个值
        二分法，findFirst() findLast() 模板
  分治
    1.给表达式加括号
      #241.为运算表达式设计优先级
        分治，递归+memorization
        动态规划，dp[i][j]记录
    2.不同的二叉搜索树
      #95.不同的二叉搜索树II
        分治，递归生成左右子树
        动态规划1，dp[i]存i个数的结果，节点数量相同的树clone加上偏差的优化
        动态规划2，依次新增n，插入之前的每个树中
  搜索
    BFS
      1.计算在网格中从原点到特定点的最短路径长度
        #1091.二进制矩阵中的最短路径
          BFS，记录路径长度
      2.组成整数的最小平方数量
        #279.完全平方数
          BFS，转换成路径问题，算小于n的平方数列表的技巧
      3.最短单词路径
        #127.单词接龙
          BFS，通用状态*优化建立邻接表
          BFS，双向搜索优化
    DFS
      1.查找最大的连通面积
        #695.岛屿的最大面积
          DFS，沉岛思想
      2.矩阵中的连通分量数目
        #200.岛屿数量
          DFS
          BFS
      3.好友关系的连通分量数目
        #547.朋友圈
          DFS，此题visited是一维数组
          UnionFind，find() 优化
      4.填充封闭区域
        #130.被围绕的区域
          DFS，先标记边缘连通的O，再修改剩余O
      5.能到达的太平洋和大西洋的区域
        #417.太平洋大西洋水流问题
          DFS，从边缘向中间dfs
    Backtracking 回溯
      1.数字键盘组合
        #17.电话号码的字母组合
          回溯，当前key的下标为prefix的长度
      2.IP 地址划分
        #93.复原 IP 地址
          回溯，level == 4 或 s.length() == 0 返回
      3.在矩阵中寻找字符串
        #79.单词搜索
          回溯，越界、字符不同、以访问则返回false
      4.输出二叉树中所有从根到叶子的路径
        #257.二叉树的所有路径
          回溯，使用辅助List<Integer>存储数据，最后再拼path，避免->的处理
      5.排列
        #46.全排列
          回溯，每次循环所有元素，添加visited为false的元素
      6.含有相同元素求排列
        #47.全排列II
          回溯，先排序，没有重复的含义是结果没有一样重复的list，而不是没有重复的数字
      7.组合
        #77.组合
          回溯，注意每次循环的起点+1，剩余数字不够时，剪枝
      8.组合求和
        #39.组合总和
          回溯，每次循环起始点从level开始
      9.含有相同元素的组合求和
        #40.组合总和II
          回溯，先排序，新去重方法 if (i > begin && candidates[i] == candidates[i - 1]) {continue;}
      10.1-9数字的组合求和
        #216.组合总和III
          回溯，k==0时返回，剪枝 if （i > target） {break;}
      11.子集
        #78.子集
          回溯，每次都添加到结果中
      12.含有相同元素求子集
        #90.子集II
          回溯，注意避免重复的两种方法 (i > start && nums[i] == nums[i - 1]) 和 visited的方式
      13.分割字符串使得每个部分都是回文数
        #131.分割回文串
          回溯，每次循环截取(start, i + 1)判断
      14.数独
        #37.解数独
          回溯，约束编程，回溯方法返回boolean值
      15.N皇后
        #51.N皇后
          回溯，45和135度对角线标记数组 r + c, n - 1 - (r - c)
  动态规划
    斐波那契数列
      1.爬楼梯
        #70.爬楼梯
          动态规划，可以用两个变量替代dp数组
      2.强盗抢劫
        #198.打家劫舍
          动态规划，两个变量初始值0，从0开始遍历
      3.强盗在环形街区抢劫
        #213.打家劫舍II
          动态规划，分为两种情况，[0, n-2]，[1, n-1]
      4.信件错排
        #N个信和信封，它们被打乱，求错误装信方式的数量
          动态规划，i->j->k，根据i=k,i!=k分两种情况，dp[i] = (i-1)*dp[i-2]+(i-1)*dp[i-1]
      5.母牛生产
        #小母牛3年后可以生产小母牛，求N年后牛的数量
          动态规划，dp[i]=dp[i-1]+dp[i-3]
    矩阵路径
      1.矩阵的最小路径和
        #64.最小路径和
          动态规划，使用二维数组作为dp；或一维数组每行更新
      2.矩阵的总路径数
        #62.不同路径
          动态规划，二维dp；或一维dp优化dp[i]+=dp[i-1]，从1开始循环
          排列组合，组合，循环计算不要用 *=，先算/会导致小数丢失
    数组区间
      1.数组区间和
        #303.区域和检索 - 数组不可变
          使用数组存储0到每一位的和
      2.数组中等差递增子区间的个数
        #413.等差数列划分
          动态规划，dp[i]表示以i结尾的等差数列数量，最后要求和
    分割整数
      1.分割整数的最大乘积
        #343.整数拆分
          动态规划，F(n)=max{i*(n-i), i*F(n-i)}
      2.按平方数来分割整数
        #279.完全平方数
          动态规划，dp[i]=Math.min(dp[i], dp[i - s] + 1);
      3.分割整数构成字母字符串
        #91.解码方法
          动态规划，根据最后一位数字的情况，分情况计算dp[i]
    最长递增子序列
      1.最长递增子序列
        #300.最长上升子序列
          动态规划，每次向前找小于当前值的最长前缀然后+1
          动态规划+二分，tail数组tail[i]存长度为i+1的最长递增子序列的最后一个元素
      2.一组整数对能够构成的最长链
        #646.最长数对链
          动态规划，dp[i]存储以pairs[i]结尾的最长链的长度
          贪心，在所有可作为下一个数对的集合中选择第二个数最小的数添加到数对链
      3.最长摆动子序列
        #376.摆动序列
          动态规划，只要up、down两个变量的优化
    最长公共子序列
      1.最长公共子序列
        #1143.最长公共子序列
          动态规划，dp[i][j]表示s1中前i个字符，s2中前j个字符的最长公共子序列长度
    0-1背包
      1.划分数组为和相等的两部分
        #416.分割等和子集
          背包，背包大小为sum/2的背包问题，dp[0]=true; dp[i]=dp[i]||dp[i-num];
      2.改变一组数的正负号使得它们的和为一给定数
        #494.目标和
          背包，转换为等和子集，dp[0]=1; dp[i]=dp[i]+dp[i-num];
          递归，当前数取正+当前数取负
      3.01字符构成最多的字符串
        #474.一和零
          背包，多维费用的0-1背包问题，dp[i][j]表示用i个0和j个1最多拼出的字符串数目
      4.找零钱的最少硬币数
        #322.零钱兑换
          背包，完全背包问题，正序遍历dp数组
      5.找零钱的硬币数组合
        #518.零钱兑换II
          背包，完全背包，使用dp记录可达成目标的组合数目，dp[0]=1（最多赞题解讲了内外层循环的区别，排列与组合）
      6.字符串按单词列表分割
        #139.单词拆分
          背包，顺序的完全背包问题，对物品的迭代放在最里层，对背包的迭代放在外层，这样才能让物品按一定顺序放入背包
      7.组合总和
        #377.组合总和IV
          背包，顺序的完全背包问题
    股票交易
      1.需要冷却期的股票交易
        #309.最佳买卖股票时机含冷冻期
          dp，dp_pre_0的技巧，dp_i_1 = Math.max(dp_i_1, dp_pre_0 - prices[i]);
      2.需要交易费用的股票交易
        #714.买卖股票的最佳时机含手续费
          dp，记录持有状态，可压缩空间
      3.只能进行两次的股票交易
        #123.买卖股票的最佳时机III
          dp，dp_i_1_1=Math.max(dp_i_1_1, -prices[i])
      4.只能进行k次的股票交易
        #188.买卖股票的最佳时机IV
          dp，先判断 k>=len/2，两层循环，交易次数也要循环
    字符串编辑
      1.删除两个字符串的字符使它们相等
        #583.两个字符串的删除操作
          dp，转换为LCS问题，也可直接dp注意if(i==0||j==0){dp[i][j]=i+j;}
      2.编辑距离
        #72.编辑距离
          dp，dp的状态变化3种情况
      3.复制粘贴字符
        #650.只有两个键的键盘
          dp，dp[i]表示需要多少步生成i；
          素数分解
  数学
    素数分解
      每一个数都可以分解成素数的乘积
    整除
      如果x整除y，则所有x的素数因子的指数小于y的素数因子的指数
    最大公约数最小公倍数
      x和y的最大公约数，所有素数因子的指数取两者的小值
      x和y的最小公倍数，所有素数因子的指数取两者的大值
      1.生成素数序列
        #204.计数质数
          每次找到一个素数时，将能被素数整除的整数排除掉
      2.最大公约数
        辗转相除法
        int gcd(int a, int b) {
          return b == 0 ? a : gcd(b, a % b);
        }
        最小公倍数为两数的乘积除以最大公约数
        int lcm(int a, int b) {
          return a * b / gcd(a, b);
        }
      3.使用过位操作和减法求解最大公约数
        更相减损法
    进制转换
      1.7进制
        #504.七进制数
          循环，除以7取余，倒序toString()，注意负数和0
      2.16进制
        #405.数字转换为十六进制数
          循环 map[num & 0b1111]; num >>>= 4;
      3.26进制
        #168.Excel表列名称
          每次循环先n--，因为从1开始，不是从0开始
    阶乘
      1.统计乘尾部有多少个0
        #172.阶乘后的零
          统计5的个数，N/5 + N/25 + N/125 ...
          可以拓展统计N!的二进制表示中最低位1的位置
    字符串加法减法
      1.二进制加法
        #67.二进制求和
          两个指针记录两个数的访问位，carry记录进位
      2.字符串加法
        #415.字符串相加
          逐位相加带上carry，carry记录进位
    相遇问题
      1.改变数组元素使所有的数组元素都相等
        #462.最少移动次数使数组元素相等II
          排序找中位数
          快速选择找中位数
    多数投票问题
      1.数组中出现次数多余n/2的元素
        #169.多数元素
          Boyer-Moore投票算法，count计数
    其他
      1.平方数
        #367.有效的完全平方数
          平方数=1+3+5+7+...
      2.3的n次方
        #326.3的幂
          循环模3，整除3
      3.乘积数组
        #238.除自身以外数组的乘积
          乘积=当前数左边的乘积*当前数右边的乘积
      4.找出数组中的乘积最大的三个数
        #628.三个数的最大乘积
          找出最小的2个数，最大的3个数，取两种乘积中的大值
***************************半连接问题
数据结构相关
  链表
    1.找出两个链表的交点
      #160.相交链表
        两个指针，一个链表尾链到另一个链表头上，a+c+b=b+c+a
    2.链表反转
      #206.反转链表
        迭代
        递归
    3.归并两个有序的链表
      #21.合并两个有序链表
        迭代，使用preHead避免判断头指针
        递归
    4.从有序链表中删除重复节点
      #83.删除排序链表中的重复元素
        迭代，prev和curr
        递归，head.val == head.next.val ? head.next : head
    5.删除链表的倒数第n个节点
      #19.删除链表的倒数第n个节点
        快慢指针，快指针先移动n次
    6.交换链表中的相邻节点
      #24.两两交换链表中的节点
        递归，
        迭代，使用一个prev指针表示前一个节点
    7.链表求和
      #445.两数相加II
        使用栈
    8.回文链表
      #234.回文链表
        快慢指针将链表切成两半，将后半段反转，然后比较两段
    9.分隔链表
      #725.分隔链表
        计算长度，与k取模和取余，迭代分隔
    10.链表元素按奇偶聚集
      #328.奇偶链表
        双指针，同时向后移动，互不干扰，最后奇链尾连偶链头
  树 31
    递归
      1.树的高度
        #104.二叉树的最大深度
          递归，1+左右子树深度的大值
      2.平衡树
        #110.平衡二叉树
          递归，计算深度，每一步判断平衡，不平衡返回特殊值（-1）
      3.两节点的最长路径
        #543.二叉树的直径
          递归，计算深度，每一步判断以该节点为根的路径
      4.翻转树
        #226.翻转二叉树
          递归，交换左右子树
      5.归并两棵树
        #617.合并二叉树
          递归，合并左右子树
      6.判断路径和是否等于一个数
        #112.路径总和
          递归，每一层减去当前的节点值
      7.统计路径和等于一个数的路径数量
        #437.路径总和III
          递归，pathSumStartWithRoot(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);
          递归+回溯，类似于数组的前n项和思路，res += map.getOrDefault(pathSum - sum, 0);
      8.子树
        #572.另一个树的子树
          递归，isSubTreeWithRoot(s, t) || isSubTree(s.left, t) || isSubTree(s.right, t);
      9.树的对称
        #101.对称二叉树
          递归，isSymmetric(l.left, r.right) && isSymmetric(l.right, r.left);
      10.最小路径
        #111.二叉树的最小深度
          递归，不能简单返回左子树和右子树中的小值，而要考虑一个子树为空的情况
      11.统计左叶子节点的和
        #404.左叶子之和
          递归，传递第二个boolean参数isLeft
      12.相同节点值的最大路径长度
        #687.最长同值路径
          递归，同值路径看作最多两个从其延伸出的箭头
      13.间隔遍历
        #337.打家劫舍III
          递归，存在重复计算，记忆化优化
          动态规划，
      14.找出二叉树中第二小的节点
        #671.二叉树中第二小的节点
          递归，如果儿子与当前节点值相同，则递归找，如果不同则拿来比较
    层次遍历
      1.一棵树每层节点的平均数
        #637.二叉树的层平均数
          BFS，队列，开始遍历一层的节点时，当前队列中的节点数就是当前层的节点数
      2.得到左下角的节点
        #513.找到树左下角的值
          BFS，遍历时，右子节点先入队列
    前中后序遍历
      1.非递归实现二叉树的前序遍历
        #144.二叉树的前序遍历
          深度优先搜索
          内层循环将所有左子节点push入栈
      2.非递归实现二叉树的后序遍历
        #145.二叉树的后序遍历
          使用辅助栈存放当前节点访问状态是从左子节点返回还是从右子节点返回
      3.非递归实现二叉树的中序遍历
        #94.二叉树的中序遍历
          在pop的时候访问
    BST
      1.修剪二叉查找树
        #669.修剪二叉搜索树
          递归，当前值与L,R比较，返回相应的修剪子树
      2.寻找二叉查找树的第k个元素
        #230.二叉搜索树中第k小的元素
          中序遍历，计数
          分治+递归，计数左子树节点个数，然后决定递归哪个子树
      3.把二叉查找树每个节点的值都加上比它大的节点的值
        先遍历右子树
      4.二叉查找树的最近公共祖先
        #235.二叉搜索树的最近公共祖先
          第一个值在p的值和q的值之间的节点
      5.二叉树的最近公共祖先
        #236.二叉树的最近公共祖先
          分别从左子树、右子树中找，左右结果都非空时返回当前节点
      6.从有序数组中构造二叉查找树
        #108.将有序数组转换为二叉搜索树
          递归+分治，中点为根节点，递归获取左右子树
      7.根据有序链表构造平衡的二叉查找树
        #109.有序链表转换二叉搜索树
          递归+分治，每次都计算链表长度，取中点为根
          中序遍历的优化，通过mid，start，end判断返回条件
      8.在二叉查找树中寻找两个节点，使它们的和为一个给定值
        #653.两数之和IV-输入BST
          中序遍历，放入list，双指针
      9.在二叉查找树中查找两个节点之差的最小绝对值
        #530.二叉搜索树的最小绝对差
          中序遍历，记录preNode，每次比较差值，取最小值
      10.寻找二叉查找树中出现次数最多的值
        #501.二叉搜索树中的众数
          中序遍历，记录前一个节点，记录currCount，maxCount，maxList
    Trie
      1.实现一个Trie
        #208.实现Trie（前缀树）
          遍历要操作的字符串，然后一层一层往下搜索TrieNode
      2.实现一个Trie，用来求前缀和
        #677.键值映射
          Trie，最后一个字符存值，找到前缀最后一个节点后，递归求求所有next的值的和
  栈和队列
    1.用栈实现队列
      #232.用栈实现队列
        当pop和peek时判断out栈是否为空，空则将in栈元素压入out栈
    2.用队列实现栈
      #225.用队列实现栈
        入队时，将前面的元素重新入队
    3.最小值栈
      #155.最小值栈
        min记录最小值，每次入栈比较，用minStack记录最小值
    4.用栈实现括号匹配
      #20.有效的括号
        使用栈存储未配对的左括号
    5.数组中元素与下一个比它大的元素之间的距离
      #739.每日温度
        遍历数组，栈中存储递减元素下标
    6.循环数组中比当前元素大的下一个元素
      #503.下一个更大的元素II
        
  哈希表 4

  字符串 9

  数组与矩阵 12

  图 4

  位运算 13
